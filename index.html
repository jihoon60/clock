<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Coke Magnetic Pixel Clock</title>
    <style>
        /* HTML과 BODY 모두 스크롤바 숨기기 강제 적용 */
        html, body {
            -ms-overflow-style: none;  /* IE and Edge */
            scrollbar-width: none;  /* Firefox */
        }
        html::-webkit-scrollbar, body::-webkit-scrollbar {
            display: none; /* Chrome, Safari, Opera */
        }

        body { 
            background-color: #000; 
            margin: 0; 
            overflow-y: auto;
            overflow-x: hidden;
            min-height: 200vh; /* 페이지 높이를 2배로 늘려서 스크롤 가능하게 */
            touch-action: pan-y;
            cursor: none;
            position: relative;
        }

        #canvas-container {
            position: fixed; /* 스크롤해도 화면 중앙에 고정 */
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            pointer-events: none; /* 캔버스 컨테이너는 클릭 방지 */
            z-index: 1;
        }
        canvas { 
            filter: drop-shadow(0 0 10px rgba(255, 0, 0, 0.7)); 
            pointer-events: auto; /* 캔버스만 클릭 가능 */
        }
        #fs-btn {
            position: fixed; 
            right: 20px; 
            bottom: 20px;
            width: 40px; 
            height: 40px;
            background: rgba(255, 0, 0, 0.2);
            border: 1px solid #FF0000; 
            border-radius: 5px;
            cursor: pointer; 
            z-index: 100;
            display: flex; 
            justify-content: center; 
            align-items: center;
            pointer-events: auto;
        }
        #fs-btn svg { fill: #FF0000; width: 24px; height: 24px; }
    </style>
</head>
<body>
<div id="canvas-container">
    <canvas id="c"></canvas>
</div>
<div id="fs-btn">
    <svg viewBox="0 0 24 24"><path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/></svg>
</div>

<script>
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d', { willReadFrequently: true });
    const fsBtn = document.getElementById('fs-btn');
    
    let particles = [];
    let bubbles = [];
    let pW = 4, pH = 5, gap = 1.0;
    const CELL_SIZE = 50;
    let spatialGrid = {};
    let mouseX = -100, mouseY = -100;

    // 터치 기기 감지 (마우스가 없는 순수 터치 기기만)
    const isTouchOnly = ('ontouchstart' in window) && 
                        (navigator.maxTouchPoints > 0) && 
                        !window.matchMedia("(pointer: fine)").matches;

    let isFullscreenMode = false;
    
    fsBtn.addEventListener('click', () => {
        const elem = document.documentElement;
        
        // 모바일 감지
        const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
        
        if (isMobile) {
            // 모바일: 브라우저 UI 숨기기
            if (!isFullscreenMode) {
                // 주소창 숨기기
                window.scrollTo(0, 1);
                document.body.style.overflow = 'hidden';
                
                // iOS 홈 화면에 추가 안내 (처음 클릭시에만)
                if (/iPhone|iPad|iPod/i.test(navigator.userAgent) && !window.navigator.standalone) {
                    console.log('iOS: 홈 화면에 추가하면 전체화면으로 사용 가능');
                }
                isFullscreenMode = true;
            } else {
                document.body.style.overflow = 'auto';
                isFullscreenMode = false;
            }
        } else {
            // PC: 기존 전체화면 API 사용
            if (!document.fullscreenElement && !document.webkitFullscreenElement) {
                if (elem.requestFullscreen) {
                    elem.requestFullscreen();
                } else if (elem.webkitRequestFullscreen) {
                    elem.webkitRequestFullscreen();
                } else if (elem.mozRequestFullScreen) {
                    elem.mozRequestFullScreen();
                } else if (elem.msRequestFullscreen) {
                    elem.msRequestFullscreen();
                }
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                } else if (document.mozCancelFullScreen) {
                    document.mozCancelFullScreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                }
            }
        }
    });

    function setPos(e) {
        if (isTouchOnly) return;
        
        mouseX = e.touches ? e.touches[0].clientX : e.clientX;
        mouseY = e.touches ? e.touches[0].clientY : e.clientY;
    }
    canvas.addEventListener('mousemove', setPos);
    canvas.addEventListener('touchstart', setPos);
    canvas.addEventListener('touchmove', (e) => { e.preventDefault(); setPos(e); }, { passive: false });

    class Particle {
        constructor(x, y) {
            this.originX = x; this.originY = y;
            this.x = x; this.y = y;
            this.vx = 0; this.vy = 0;
            this.friction = 0.85; this.spring = 0.08;
        }
        update(nearbyBubbles) {
            nearbyBubbles.forEach(b => {
                const dx = this.x - b.x, dy = this.y - b.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < b.size * 4 && dist > 0) {
                    const force = (b.size * 4 - dist) / (b.size * 4);
                    this.vx += (dx / dist) * force * force * 1.5;
                    this.vy += (dy / dist) * force * force * 1.5;
                }
            });
            this.vx += (this.originX - this.x) * this.spring;
            this.vy += (this.originY - this.y) * this.spring;
            this.vx *= this.friction; this.vy *= this.friction;
            this.x += this.vx; this.y += this.vy;
        }
        draw() { ctx.fillStyle = "#FF0000"; ctx.fillRect(this.x, this.y, pW, pH); }
    }

    class Bubble {
        constructor(isInitial = false) { this.reset(isInitial); }
        reset(isInitial) {
            this.x = Math.random() * window.innerWidth;
            this.y = isInitial ? Math.random() * window.innerHeight : window.innerHeight + 50;
            this.size = Math.random() * 8 + 4;
            this.speed = 2.5; this.opacity = Math.random() * 0.25 + 0.15;
            this.angle = Math.random() * Math.PI * 2;
        }
        update() {
            this.y -= this.speed;
            this.x += Math.sin(this.angle += 0.02) * 1.5;
            if (this.y < -50) this.reset(false);
        }
        draw() {
            ctx.fillStyle = `rgba(255, 0, 0, ${this.opacity})`;
            ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill();
        }
    }

    function buildSpatialGrid() {
        spatialGrid = {};
        bubbles.forEach(b => {
            const key = `${Math.floor(b.x / CELL_SIZE)},${Math.floor(b.y / CELL_SIZE)}`;
            if (!spatialGrid[key]) spatialGrid[key] = [];
            spatialGrid[key].push(b);
        });
    }

    function getNearbyBubbles(x, y) {
        const cX = Math.floor(x / CELL_SIZE), cY = Math.floor(y / CELL_SIZE);
        const nearby = [];
        for (let dx = -1; dx <= 1; dx++) {
            for (let dy = -1; dy <= 1; dy++) {
                const key = `${cX + dx},${cY + dy}`;
                if (spatialGrid[key]) nearby.push(...spatialGrid[key]);
            }
        }
        return nearby;
    }

    function init() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        bubbles = Array.from({ length: 60 }, () => new Bubble(true));
        lastTime = "";
    }

    let lastTime = "";
    function updateParticles() {
        const time = new Date().toTimeString().split(' ')[0];
        if (time === lastTime) return;
        lastTime = time;

        const mCanvas = document.createElement('canvas');
        const mctx = mCanvas.getContext('2d');
        
        const isLandscape = window.innerWidth > window.innerHeight;
        const targetDisplayWidth = isLandscape ? canvas.width * 0.8 : canvas.width * 0.95;
        const targetDisplayHeight = isLandscape ? canvas.height * 0.6 : canvas.height * 0.35;
        
        const particleSize = pW + gap;
        const particlesWide = Math.floor(targetDisplayWidth / particleSize);
        const textWidth = particlesWide;
        const textHeight = Math.floor(targetDisplayHeight / particleSize);
        
        mCanvas.width = textWidth;
        mCanvas.height = textHeight;
        
        const fontSize = textWidth / 6;
        mctx.font = `900 ${fontSize}px Arial Black, Arial, sans-serif`;
        mctx.textAlign = "center";
        mctx.textBaseline = "middle";
        mctx.strokeStyle = "white";
        mctx.lineWidth = Math.max(1.5, fontSize / 25);
        mctx.strokeText(time, textWidth / 2, textHeight / 2);
        mctx.fillStyle = "white";
        mctx.fillText(time, textWidth / 2, textHeight / 2);

        const data = mctx.getImageData(0, 0, textWidth, textHeight).data;
        
        const displayWidth = textWidth * particleSize;
        const displayHeight = textHeight * particleSize;
        const startX = (canvas.width - displayWidth) / 2;
        const startY = (canvas.height - displayHeight) / 2;

        const newParticles = [];
        for (let y = 0; y < textHeight; y++) {
            for (let x = 0; x < textWidth; x++) {
                if (data[(y * textWidth + x) * 4 + 3] > 128) {
                    const px = startX + x * particleSize;
                    const py = startY + y * particleSize;
                    newParticles.push(new Particle(px, py));
                }
            }
        }
        particles = newParticles;
    }

    function animate() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        updateParticles();
        buildSpatialGrid();
        bubbles.forEach(b => { b.update(); b.draw(); });
        particles.forEach(p => { 
            p.update(getNearbyBubbles(p.x, p.y)); 
            p.draw(); 
        });
        
        if (!isTouchOnly) {
            ctx.strokeStyle = "#FF0000"; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.arc(mouseX, mouseY, 16, 0, Math.PI * 2); ctx.stroke();
        }
        requestAnimationFrame(animate);
    }

    init(); animate();
    window.onresize = init;
</script>
</body>
</html>